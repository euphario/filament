#!/bin/bash
# Build script for BPI-R4 kernel user programs
# Supports incremental builds - only regenerates *_elf.rs if ELF changed
#
# Usage:
#   ./build.sh           # Build all programs (incremental)
#   ./build.sh clean     # Full rebuild
#   ./build.sh devd      # Build only devd
#   ./build.sh consoled shell  # Build only consoled and shell

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
cd "$SCRIPT_DIR"

# All programs (name:path pairs, path defaults to name if not specified)
# Core services (migrated to unified IPC)
ALL_PROGRAMS="devd:driver/devd consoled:driver/consoled shell"
# DISABLED (need migration): logd:driver/logd gpio:driver/gpio usbd:driver/usbd fatfs:driver/fatfs pcied:driver/pcied vfsd:driver/vfsd wifid:driver/wifid pwm:driver/pwm nvmed:driver/nvmed pciepoke:driver/pciepoke

# Handle clean
if [ "$1" = "clean" ]; then
    echo "Cleaning bin/..."
    rm -rf bin
    shift
fi

mkdir -p bin

# Determine which programs to build
if [ $# -gt 0 ]; then
    # Build only specified programs
    PROGRAMS=""
    for arg in "$@"; do
        for entry in $ALL_PROGRAMS; do
            prog="${entry%%:*}"
            if [ "$prog" = "$arg" ]; then
                PROGRAMS="$PROGRAMS $entry"
                break
            fi
        done
    done
else
    # Build all
    PROGRAMS="$ALL_PROGRAMS"
fi

# Build each program
for entry in $PROGRAMS; do
    # Split name:path, default path to name
    prog="${entry%%:*}"
    path="${entry#*:}"
    if [ "$path" = "$prog" ]; then
        path="$prog"
    fi

    echo "Building $prog (from $path)..."

    # Build with cargo (from the program's directory)
    # Override rustflags to prevent kernel's linker script from being used
    (cd "$path" && RUSTFLAGS="-C link-arg=-Tuser.ld -C link-arg=--gc-sections -C link-arg=-n" cargo build --release 2>&1 | grep -v "Compiling\|Finished" || true)

    ELF_SRC="target/aarch64-unknown-none/release/$prog"
    ELF_DST="bin/$prog.elf"
    ELF_RS="bin/${prog}_elf.rs"

    # Check if ELF changed (skip regeneration if unchanged)
    if [ -f "$ELF_DST" ] && cmp -s "$ELF_SRC" "$ELF_DST"; then
        echo "  (unchanged)"
        continue
    fi

    # Copy ELF to bin directory
    cp "$ELF_SRC" "$ELF_DST"

    # Convert to raw binary
    rust-objcopy -O binary "$ELF_SRC" "bin/$prog.bin"

    # Show size info
    echo "  ELF: $(ls -lh "$ELF_DST" | awk '{print $5}')"
    echo "  BIN: $(ls -lh "bin/$prog.bin" | awk '{print $5}')"

    # Generate Rust include file for embedding in kernel
    PROG_UPPER=$(echo "$prog" | tr '[:lower:]' '[:upper:]')
    echo "  Generating ${prog}_elf.rs..."
    {
        echo "//! Auto-generated ELF binary for $prog"
        echo "//! Generated by user/build.sh"
        echo ""
        echo "#[rustfmt::skip]"
        echo "pub static ${PROG_UPPER}_ELF: &[u8] = &["
        xxd -i < "$ELF_DST" | sed 's/^/    /'
        echo "];"
    } > "$ELF_RS"
done

echo ""
echo "Build complete!"
echo ""
echo "Files generated in: $SCRIPT_DIR/bin/"
echo "  - *.elf   : ELF executables"
echo "  - *.bin   : Raw binaries"
echo "  - *_elf.rs: Rust files for embedding in kernel"
echo ""
echo "To embed in kernel, copy the *_elf.rs content to src/elf.rs"
